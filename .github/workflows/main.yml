name: Main Branch Deployment

on:
  push:
    branches: [main]
    paths:
      - 'services/**'
      - 'libs/**'
      - 'apps/web/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: main-deploy
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  deployments: write
  actions: read

jobs:
  # =============================================================================
  # PRE-DEPLOYMENT VERIFICATION
  # =============================================================================

  pre-deployment-checks:
    name: Pre-deployment Verification
    runs-on: ubuntu-latest
    timeout-minutes: 25

    outputs:
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
      deploy_backend: ${{ steps.decision.outputs.deploy_backend }}
      deploy_frontend: ${{ steps.decision.outputs.deploy_frontend }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check previous run status
        id: check_previous
        uses: actions/github-script@v7
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'main.yml',
              branch: 'main',
              per_page: 3
            });
            // Look for the previous run (not the current one)
            const previousRun = runs.data.workflow_runs.find(run => run.id !== context.runId);
            const failed = previousRun && previousRun.conclusion === 'failure';
            console.log(`Previous run: ${previousRun?.id}, conclusion: ${previousRun?.conclusion}`);
            core.setOutput('previous_failed', failed ? 'true' : 'false');
            return failed;

      - name: Get last successful deployment
        id: last_success
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the SHA of the last successful main workflow run
          LAST_SUCCESS=$(gh run list --workflow=main.yml --status=success --limit=1 --json headSha -q '.[0].headSha' 2>/dev/null || echo "")
          if [ -z "$LAST_SUCCESS" ]; then
            # Fallback to HEAD~1 if no successful runs found
            LAST_SUCCESS="HEAD~1"
            echo "No previous successful deployment found, using HEAD~1"
          else
            echo "Last successful deployment: $LAST_SUCCESS"
          fi
          echo "last_success_sha=${LAST_SUCCESS}" >> $GITHUB_OUTPUT

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          base: ${{ steps.last_success.outputs.last_success_sha }}
          filters: |
            backend:
              - 'services/**'
              - 'libs/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
            frontend:
              - 'apps/web/**'

      - name: Install Rust toolchain
        if: steps.changes.outputs.backend == 'true'
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Quick smoke tests
        if: steps.changes.outputs.backend == 'true'
        timeout-minutes: 5
        run: |
          cargo check --workspace
          cargo test --lib --workspace -- --test-threads=1

      - name: Setup Node.js and pnpm for frontend checks
        if: steps.changes.outputs.frontend == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm for frontend checks
        if: steps.changes.outputs.frontend == 'true'
        uses: pnpm/action-setup@v4

      - name: Frontend quick checks
        if: steps.changes.outputs.frontend == 'true'
        working-directory: apps/web
        run: |
          pnpm install --frozen-lockfile
          pnpm run type-check
          pnpm run lint

      - name: Deployment decision
        id: decision
        run: |
          backend_changed="${{ steps.changes.outputs.backend }}"
          frontend_changed="${{ steps.changes.outputs.frontend }}"
          previous_failed="${{ steps.check_previous.outputs.previous_failed }}"
          is_manual="${{ github.event_name == 'workflow_dispatch' }}"

          echo "=== Deployment Decision Analysis ==="
          echo "Backend changed: $backend_changed"
          echo "Frontend changed: $frontend_changed"
          echo "Previous run failed: $previous_failed"
          echo "Manual trigger: $is_manual"
          echo "=================================="

          if [ "$backend_changed" == "true" ] || [ "$frontend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            
            # Set deploy flags for individual components
            if [ "$backend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
              echo "deploy_backend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy_backend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$frontend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
              echo "deploy_frontend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy_frontend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$previous_failed" == "true" ]; then
              echo "âœ… Deployment triggered - Recovering from previous failed run (Backend: ${deploy_backend:-false}, Frontend: ${deploy_frontend:-false})"
            elif [ "$is_manual" == "true" ]; then
              echo "âœ… Deployment triggered - Manual workflow dispatch (Backend: ${deploy_backend:-false}, Frontend: ${deploy_frontend:-false})"
            else
              echo "âœ… Deployment triggered - Changes detected (Backend: $backend_changed, Frontend: $frontend_changed)"
            fi
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "deploy_backend=false" >> $GITHUB_OUTPUT
            echo "deploy_frontend=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No deployment needed - No changes, no previous failure, not manual"
          fi

  # =============================================================================
  # BUILD & PACKAGE ARTIFACTS
  # =============================================================================

  build-backend:
    name: Build API Gateway (Consolidated Services)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_backend == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: 'rust-main-deploy'
          cache-all-crates: 'true'

      - name: Build API Gateway
        run: |
          echo "Building consolidated API Gateway with all services..."
          cargo build --release --package api-gateway

      - name: Generate SBOM
        run: |
          cargo install cargo-cyclonedx
          cargo cyclonedx --format json > sbom-api-gateway.json

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-gateway-binary
          path: |
            target/release/api-gateway
            sbom-api-gateway.json
          retention-days: 7

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_frontend == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        working-directory: apps/web
        run: pnpm install --frozen-lockfile

      - name: Build application
        working-directory: apps/web
        run: pnpm build
        env:
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.STAGING_CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.STAGING_CLERK_SECRET_KEY }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          NEXT_PUBLIC_ENABLE_AI_FEATURES: true
          NEXT_PUBLIC_ENABLE_MOCK_DATA: false

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: |
            apps/web/.next
            apps/web/public
            apps/web/package.json
          retention-days: 7
          if-no-files-found: error

  # =============================================================================
  # STAGING DEPLOYMENT
  # =============================================================================

  deploy-staging-backend:
    name: Deploy API Gateway to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deployment-checks, build-backend]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_backend == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Shuttle CLI
        run: |
          # First install cargo-binstall for faster installation
          curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash

          # Force install cargo-shuttle (override any cached/broken installation)  
          cargo binstall -y --locked --force cargo-shuttle

          # Verify installation
          echo "Verifying cargo-shuttle installation:"
          ls -la ~/.cargo/bin/cargo-shuttle || echo "cargo-shuttle not found!"

          # Create shuttle symlink for shuttle.dev platform  
          ln -sf ~/.cargo/bin/cargo-shuttle ~/.cargo/bin/shuttle

          # Export PATH to ensure shuttle is available
          export PATH="$HOME/.cargo/bin:$PATH"
          echo "PATH=$HOME/.cargo/bin:$PATH" >> $GITHUB_ENV

      # Skip artifact download - deploy from source instead
      # - name: Download build artifacts
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: api-gateway-binary
      #     path: ./artifacts

      # - name: Create Secrets file for staging
      #   working-directory: services/api-gateway
      #   run: |
      #     cat > Secrets.toml << EOF
      #     CLERK_DOMAIN = "${{ secrets.STAGING_CLERK_DOMAIN }}"
      #     CLERK_JWKS_URL = "${{ secrets.STAGING_CLERK_JWKS_URL }}"
      #     CLERK_AUDIENCE = "${{ secrets.STAGING_CLERK_JWT_AUDIENCE }}"
      #     CLERK_WEBHOOK_SECRET = "${{ secrets.STAGING_CLERK_WEBHOOK_SECRET }}"
      #     EOF
      #     echo "Created Secrets.toml for staging deployment"

      - name: Deploy to Shuttle staging
        run: |
          cargo shuttle login --api-key ${{ secrets.SHUTTLE_API_KEY }}

          # Deploy with staging suffix
          PROJECT_NAME="salunga-ai-staging"

          # Check if staging project exists, create if not  
          if ! cargo shuttle project status --name $PROJECT_NAME 2>/dev/null; then
            echo "Creating staging project: $PROJECT_NAME"
            cargo shuttle project new --name $PROJECT_NAME
          fi

          # Deploy to staging - from api-gateway directory ensures correct service is deployed
          export PATH="$HOME/.cargo/bin:$PATH"
          cd services/api-gateway
          cargo shuttle deploy --name $PROJECT_NAME

  deploy-staging-frontend:
    name: Deploy Frontend to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment-checks, build-frontend]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_frontend == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        working-directory: apps/web
        run: pnpm install --frozen-lockfile

      - name: Verify Vercel secrets
        run: |
          echo "Checking Vercel configuration..."
          if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
            echo "âŒ VERCEL_TOKEN is not set"
            exit 1
          fi
          if [ -z "${{ secrets.VERCEL_ORG_ID }}" ]; then
            echo "âŒ VERCEL_ORG_ID is not set"
            exit 1
          fi
          if [ -z "${{ secrets.VERCEL_PROJECT_ID }}" ]; then
            echo "âŒ VERCEL_PROJECT_ID is not set"
            exit 1
          fi
          echo "âœ… All required Vercel secrets are present"

      - name: Deploy to Vercel staging
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: apps/web
          github-comment: false
          alias-domains: |
            staging-battra-ai.vercel.app

  # =============================================================================
  # REGRESSION TESTING ON STAGING
  # =============================================================================

  staging-regression-tests:
    name: Staging Regression Tests
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [deploy-staging-backend, deploy-staging-frontend]
    if: always() && (needs.deploy-staging-backend.result == 'success' || needs.deploy-staging-frontend.result == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install Playwright
        working-directory: apps/web
        run: |
          pnpm install --frozen-lockfile
          pnpm playwright install --with-deps

      - name: Validate staging deployment readiness
        run: |
          echo "Validating staging deployment readiness..."

          # Function to check endpoint with retries and detailed diagnostics
          check_endpoint() {
            local url=$1
            local name=$2
            local max_attempts=30
            local wait_time=10
            
            echo "Checking $name at $url"
            
            for i in $(seq 1 $max_attempts); do
              echo "Attempt $i/$max_attempts for $name..."
              
              # Get more detailed response information
              response=$(curl -s -o /dev/null -w "%{http_code},%{time_total},%{url_effective}" --max-time 10 "$url" 2>/dev/null || echo "000,999,timeout")
              http_code=$(echo $response | cut -d',' -f1)
              time_total=$(echo $response | cut -d',' -f2)
              effective_url=$(echo $response | cut -d',' -f3)
              
              if [ "$http_code" == "200" ]; then
                echo "âœ… $name is ready (${http_code}, ${time_total}s)"
                return 0
              elif [ "$http_code" == "000" ]; then
                echo "âš ï¸ $name: Connection failed (timeout or DNS issue)"
              else
                echo "âš ï¸ $name: HTTP $http_code (${time_total}s) - may still be starting up"
              fi
              
              if [ $i -lt $max_attempts ]; then
                echo "â³ $name not ready, waiting ${wait_time}s..."
                sleep $wait_time
              fi
            done
            
            echo "âŒ $name failed to become ready after $((max_attempts * wait_time)) seconds"
            echo "Final status: HTTP $http_code, Time: ${time_total}s"
            return 1
          }

          # Check staging frontend
          if [ -n "${{ secrets.STAGING_BASE_URL }}" ]; then
            check_endpoint "${{ secrets.STAGING_BASE_URL }}" "Staging Frontend"
          else
            echo "âš ï¸ STAGING_BASE_URL not configured, skipping frontend check"
          fi

          # Check staging API
          if [ -n "${{ secrets.STAGING_API_BASE_URL }}" ]; then
            check_endpoint "${{ secrets.STAGING_API_BASE_URL }}/health" "Staging API Health"
            check_endpoint "${{ secrets.STAGING_API_BASE_URL }}/ready" "Staging API Ready"
          else
            echo "âŒ STAGING_API_BASE_URL not configured"
            exit 1
          fi

          echo "âœ… All staging services are ready for testing"

      - name: Run comprehensive staging smoke tests
        working-directory: apps/web
        timeout-minutes: 20
        run: |
          echo "Running staging smoke tests..."

          # Set test environment variables with fallbacks
          export PLAYWRIGHT_BASE_URL="${{ secrets.STAGING_BASE_URL }}"
          export STAGING_BASE_URL="${{ secrets.STAGING_BASE_URL }}"
          export STAGING_API_BASE_URL="${{ secrets.STAGING_API_BASE_URL }}"

          # Validate test configuration
          if [ -z "$PLAYWRIGHT_BASE_URL" ] || [ -z "$STAGING_API_BASE_URL" ]; then
            echo "âŒ Missing required staging URLs for testing"
            echo "STAGING_BASE_URL: ${STAGING_BASE_URL:-'Not set'}"
            echo "STAGING_API_BASE_URL: ${STAGING_API_BASE_URL:-'Not set'}"
            exit 1
          fi

          echo "Test configuration:"
          echo "Frontend URL: $STAGING_BASE_URL"
          echo "API URL: $STAGING_API_BASE_URL"
          echo "Test timeout: 20 minutes"

          # Run tests with retry on failure
          if ! pnpm test:e2e:staging; then
            echo "âš ï¸ First test run failed, retrying once..."
            sleep 30
            pnpm test:e2e:staging
          fi
        env:
          PLAYWRIGHT_BASE_URL: ${{ secrets.STAGING_BASE_URL }}
          STAGING_BASE_URL: ${{ secrets.STAGING_BASE_URL }}
          STAGING_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          CI: true

      - name: Run comprehensive API tests
        timeout-minutes: 10
        run: |
          echo "Running comprehensive API tests..."
          API_URL="${{ secrets.STAGING_API_BASE_URL }}"

          if [ -z "$API_URL" ]; then
            echo "âŒ STAGING_API_BASE_URL not configured"
            exit 1
          fi

          # Test core endpoints with detailed reporting
          test_endpoint() {
            local endpoint=$1
            local expected_code=${2:-200}
            local url="$API_URL/$endpoint"
            
            echo "Testing $endpoint..."
            response=$(curl -s -o /dev/null -w "%{http_code},%{time_total}" --max-time 15 "$url" || echo "000,999")
            code=$(echo $response | cut -d',' -f1)
            time=$(echo $response | cut -d',' -f2)
            
            if [ "$code" == "$expected_code" ]; then
              echo "âœ… $endpoint: OK (${code}, ${time}s)"
              return 0
            else
              echo "âŒ $endpoint: Failed (${code}, ${time}s)"
              return 1
            fi
          }

          # Core health endpoints
          test_endpoint "health" 200
          test_endpoint "ready" 200

          # Service-specific health endpoints through unified gateway
          test_endpoint "api/v1/projects/health" 200
          test_endpoint "api/v1/backlog/health" 200  
          test_endpoint "api/v1/readiness/health" 200
          test_endpoint "api/v1/prompt-builder/health" 200

          # Test authentication endpoints (should return 401 without auth)
          test_endpoint "api/v1/projects" 401
          test_endpoint "api/v1/backlog/stories" 401

          echo "âœ… All API tests completed successfully"

      - name: Performance benchmarking
        timeout-minutes: 5
        run: |
          echo "Running performance benchmarks..."
          API_URL="${{ secrets.STAGING_API_BASE_URL }}"

          # Performance test function
          benchmark_endpoint() {
            local endpoint=$1
            local threshold=${2:-2.0}
            local iterations=5
            
            echo "Benchmarking $endpoint (${iterations} iterations)..."
            
            total_time=0
            for i in $(seq 1 $iterations); do
              time=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "$API_URL/$endpoint" || echo "999")
              echo "  Iteration $i: ${time}s"
              total_time=$(echo "$total_time + $time" | bc -l)
            done
            
            avg_time=$(echo "scale=3; $total_time / $iterations" | bc -l)
            echo "Average response time: ${avg_time}s (threshold: ${threshold}s)"
            
            if (( $(echo "$avg_time > $threshold" | bc -l) )); then
              echo "âŒ Performance threshold exceeded: ${avg_time}s > ${threshold}s"
              return 1
            else
              echo "âœ… Performance benchmark passed: ${avg_time}s"
              return 0
            fi
          }

          # Benchmark key endpoints
          benchmark_endpoint "health" 1.0
          benchmark_endpoint "ready" 1.0  
          benchmark_endpoint "api/v1/projects/health" 2.0
          benchmark_endpoint "api/v1/backlog/health" 2.0

          echo "âœ… All performance benchmarks completed"

      - name: Generate test results summary
        if: always()
        run: |
          echo "## ðŸ§ª Staging Smoke Test Results" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Staging" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend URL:** ${{ secrets.STAGING_BASE_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** ${{ secrets.STAGING_API_BASE_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**Test Suite:** E2E Staging Smoke Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "apps/web/test-results/staging-results.json" ]; then
            echo "**Test Results:** Available in artifacts" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Test Results:** No results file generated" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Quality Gates:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Deployment health validation" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ§ª Frontend smoke tests" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”§ API integration tests" >> $GITHUB_STEP_SUMMARY
          echo "- âš¡ Performance benchmarks" >> $GITHUB_STEP_SUMMARY

      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-smoke-test-results
          path: |
            apps/web/playwright-report/
            apps/web/test-results/
            apps/web/test-results/staging-results.json
            apps/web/test-results/staging-results.xml
          retention-days: 30
          if-no-files-found: warn

  # =============================================================================
  # PRODUCTION DEPLOYMENT PREPARATION
  # =============================================================================

  create-production-deployment:
    name: Create Production Deployment Request
    runs-on: ubuntu-latest
    needs: [staging-regression-tests]
    if: success() && github.ref == 'refs/heads/main'

    outputs:
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}

    steps:
      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment from main branch',
              required_contexts: [],
              auto_merge: false
            });

            core.setOutput('deployment_id', deployment.id);

            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.id,
              state: 'pending',
              description: 'Awaiting manual approval for production deployment'
            });

  # =============================================================================
  # NOTIFICATIONS & SUMMARY
  # =============================================================================

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    if: always()
    needs:
      [
        pre-deployment-checks,
        deploy-staging-backend,
        deploy-staging-frontend,
        staging-regression-tests,
        create-production-deployment,
      ]

    steps:
      - name: Generate deployment summary
        run: |
          echo "## ðŸš€ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Single API Gateway (Consolidated Services)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.pre-deployment-checks.outputs.should_deploy }}" == "true" ]; then
            echo "âœ… **Pre-deployment checks:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "â­ï¸ **Deployment skipped:** No changes detected" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # API Gateway deployment status (includes all services)
          if [ "${{ needs.pre-deployment-checks.outputs.backend_changed }}" == "true" ]; then
            if [ "${{ needs.deploy-staging-backend.result }}" == "success" ]; then
              echo "âœ… **API Gateway deployment:** Successful (All services included)" >> $GITHUB_STEP_SUMMARY
              echo "   - Projects service: Available at /api/v1/projects" >> $GITHUB_STEP_SUMMARY
              echo "   - Backlog service: Available at /api/v1/backlog" >> $GITHUB_STEP_SUMMARY
              echo "   - Readiness service: Available at /api/v1/readiness" >> $GITHUB_STEP_SUMMARY
              echo "   - Prompt Builder service: Available at /api/v1/prompt-builder" >> $GITHUB_STEP_SUMMARY
              echo "   - Context Orchestrator service: Available at /api/v1/context-orchestrator" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **API Gateway deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Frontend deployment status
          if [ "${{ needs.pre-deployment-checks.outputs.frontend_changed }}" == "true" ]; then
            if [ "${{ needs.deploy-staging-frontend.result }}" == "success" ]; then
              echo "âœ… **Frontend deployment:** Successful" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Frontend deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Regression tests status
          if [ "${{ needs.staging-regression-tests.result }}" == "success" ]; then
            echo "âœ… **Regression tests:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Regression tests:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Production deployment status
          if [ "${{ needs.create-production-deployment.result }}" == "success" ]; then
            echo "ðŸŽ¯ **Production deployment:** Ready for approval" >> $GITHUB_STEP_SUMMARY
            echo "[Approve Production Deployment](https://github.com/${{ github.repository }}/deployments)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "- Review staging environment" >> $GITHUB_STEP_SUMMARY
          echo "- Approve production deployment when ready" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment metrics" >> $GITHUB_STEP_SUMMARY

      - name: Notify team
        if: failure()
        run: |
          echo "ðŸš¨ Staging deployment failed for commit ${{ github.sha }}"
          echo "Check the workflow run for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
