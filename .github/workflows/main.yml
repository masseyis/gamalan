name: Main Branch Deployment

on:
  push:
    branches: [ main ]
    paths: 
      - 'services/**'
      - 'libs/**'
      - 'apps/web/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: main-deploy
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  deployments: write
  actions: read

jobs:
  # =============================================================================
  # PRE-DEPLOYMENT VERIFICATION
  # =============================================================================
  
  pre-deployment-checks:
    name: Pre-deployment Verification
    runs-on: ubuntu-latest
    timeout-minutes: 25
    
    outputs:
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
      deploy_backend: ${{ steps.decision.outputs.deploy_backend }}
      deploy_frontend: ${{ steps.decision.outputs.deploy_frontend }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Check previous run status
        id: check_previous
        uses: actions/github-script@v7
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'main.yml',
              branch: 'main',
              per_page: 3
            });
            // Look for the previous run (not the current one)
            const previousRun = runs.data.workflow_runs.find(run => run.id !== context.runId);
            const failed = previousRun && previousRun.conclusion === 'failure';
            console.log(`Previous run: ${previousRun?.id}, conclusion: ${previousRun?.conclusion}`);
            core.setOutput('previous_failed', failed ? 'true' : 'false');
            return failed;
            
      - name: Get last successful deployment
        id: last_success
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the SHA of the last successful main workflow run
          LAST_SUCCESS=$(gh run list --workflow=main.yml --status=success --limit=1 --json headSha -q '.[0].headSha' 2>/dev/null || echo "")
          if [ -z "$LAST_SUCCESS" ]; then
            # Fallback to HEAD~1 if no successful runs found
            LAST_SUCCESS="HEAD~1"
            echo "No previous successful deployment found, using HEAD~1"
          else
            echo "Last successful deployment: $LAST_SUCCESS"
          fi
          echo "last_success_sha=${LAST_SUCCESS}" >> $GITHUB_OUTPUT
          
      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          base: ${{ steps.last_success.outputs.last_success_sha }}
          filters: |
            backend:
              - 'services/**'
              - 'libs/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
            frontend:
              - 'apps/web/**'
              
      - name: Install Rust toolchain
        if: steps.changes.outputs.backend == 'true'
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          
      - name: Quick smoke tests
        if: steps.changes.outputs.backend == 'true'
        timeout-minutes: 5
        run: |
          cargo check --workspace
          cargo test --lib --workspace -- --test-threads=1
          
      - name: Frontend quick checks
        if: steps.changes.outputs.frontend == 'true'
        working-directory: apps/web
        run: |
          npm ci
          npm run type-check
          npm run lint
          
      - name: Deployment decision
        id: decision
        run: |
          backend_changed="${{ steps.changes.outputs.backend }}"
          frontend_changed="${{ steps.changes.outputs.frontend }}"
          previous_failed="${{ steps.check_previous.outputs.previous_failed }}"
          is_manual="${{ github.event_name == 'workflow_dispatch' }}"
          
          echo "=== Deployment Decision Analysis ==="
          echo "Backend changed: $backend_changed"
          echo "Frontend changed: $frontend_changed"
          echo "Previous run failed: $previous_failed"
          echo "Manual trigger: $is_manual"
          echo "=================================="
          
          if [ "$backend_changed" == "true" ] || [ "$frontend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            
            # Set deploy flags for individual components
            if [ "$backend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
              echo "deploy_backend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy_backend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$frontend_changed" == "true" ] || [ "$previous_failed" == "true" ] || [ "$is_manual" == "true" ]; then
              echo "deploy_frontend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy_frontend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$previous_failed" == "true" ]; then
              echo "✅ Deployment triggered - Recovering from previous failed run (Backend: ${deploy_backend:-false}, Frontend: ${deploy_frontend:-false})"
            elif [ "$is_manual" == "true" ]; then
              echo "✅ Deployment triggered - Manual workflow dispatch (Backend: ${deploy_backend:-false}, Frontend: ${deploy_frontend:-false})"
            else
              echo "✅ Deployment triggered - Changes detected (Backend: $backend_changed, Frontend: $frontend_changed)"
            fi
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "deploy_backend=false" >> $GITHUB_OUTPUT
            echo "deploy_frontend=false" >> $GITHUB_OUTPUT
            echo "ℹ️ No deployment needed - No changes, no previous failure, not manual"
          fi

  # =============================================================================
  # BUILD & PACKAGE ARTIFACTS
  # =============================================================================
  
  build-backend:
    name: Build API Gateway (Consolidated Services)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_backend == 'true'
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          
      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "rust-main-deploy"
          cache-all-crates: "true"
          
      - name: Build API Gateway
        run: |
          echo "Building consolidated API Gateway with all services..."
          cargo build --release --package api-gateway
          
      - name: Generate SBOM
        run: |
          cargo install cargo-cyclonedx
          cargo cyclonedx --format json > sbom-api-gateway.json
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-gateway-binary
          path: |
            target/release/api-gateway
            sbom-api-gateway.json
          retention-days: 7

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_frontend == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        
      - name: Install dependencies
        working-directory: apps/web
        run: pnpm install --frozen-lockfile
        
      - name: Build application
        working-directory: apps/web
        run: pnpm build
        env:
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.STAGING_CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.STAGING_CLERK_SECRET_KEY }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          NEXT_PUBLIC_ENABLE_AI_FEATURES: true
          NEXT_PUBLIC_ENABLE_MOCK_DATA: false
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: |
            apps/web/.next
            apps/web/public
            apps/web/package.json
          retention-days: 7
          if-no-files-found: error

  # =============================================================================
  # STAGING DEPLOYMENT
  # =============================================================================
  
  deploy-staging-backend:
    name: Deploy API Gateway to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deployment-checks, build-backend]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_backend == 'true'
    environment: staging
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install Shuttle CLI
        run: |
          # First install cargo-binstall for faster installation
          curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
          
          # Force install cargo-shuttle (override any cached/broken installation)  
          cargo binstall -y --locked --force cargo-shuttle
          
          # Verify installation
          echo "Verifying cargo-shuttle installation:"
          ls -la ~/.cargo/bin/cargo-shuttle || echo "cargo-shuttle not found!"
          
          # Create shuttle symlink for shuttle.dev platform  
          ln -sf ~/.cargo/bin/cargo-shuttle ~/.cargo/bin/shuttle
          
          # Export PATH to ensure shuttle is available
          export PATH="$HOME/.cargo/bin:$PATH"
          echo "PATH=$HOME/.cargo/bin:$PATH" >> $GITHUB_ENV
          
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: api-gateway-binary
          path: ./artifacts
          
      - name: Deploy to Shuttle staging
        run: |
          cd services/api-gateway
          cargo shuttle login --api-key ${{ secrets.SHUTTLE_API_KEY }}
          
          # Deploy with staging suffix
          PROJECT_NAME="salunga-ai-staging"
          
          # Check if staging project exists, create if not  
          if ! cargo shuttle project status --name $PROJECT_NAME 2>/dev/null; then
            echo "Creating staging project: $PROJECT_NAME"
            cargo shuttle project new --name $PROJECT_NAME
          fi
          
          # Deploy to staging
          export PATH="$HOME/.cargo/bin:$PATH"
          cargo shuttle deploy --name $PROJECT_NAME
        env:
          # Shuttle-managed database is automatically provided via #[Postgres] annotation
          CLERK_WEBHOOK_SECRET: ${{ secrets.STAGING_CLERK_WEBHOOK_SECRET }}
          CLERK_JWKS_URL: ${{ secrets.STAGING_CLERK_JWKS_URL }}
          CLERK_JWT_ISSUER: ${{ secrets.STAGING_CLERK_JWT_ISSUER }}
          CLERK_JWT_AUDIENCE: ${{ secrets.STAGING_CLERK_JWT_AUDIENCE }}

  deploy-staging-frontend:
    name: Deploy Frontend to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment-checks, build-frontend]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true' && needs.pre-deployment-checks.outputs.deploy_frontend == 'true'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: apps/web/.next
          
      - name: Deploy to Vercel staging
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--env staging'
          working-directory: apps/web
        env:
          VERCEL_ENV: staging

  # =============================================================================
  # REGRESSION TESTING ON STAGING
  # =============================================================================
  
  staging-regression-tests:
    name: Staging Regression Tests
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [deploy-staging-backend, deploy-staging-frontend]
    if: always() && (needs.deploy-staging-backend.result == 'success' || needs.deploy-staging-frontend.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        
      - name: Install Playwright
        working-directory: apps/web
        run: |
          pnpm install --frozen-lockfile
          pnpm playwright install --with-deps
          
      - name: Wait for staging deployment
        run: |
          echo "Waiting 60 seconds for deployments to stabilize..."
          sleep 60
          
      - name: Run smoke tests
        working-directory: apps/web
        run: |
          pnpm test:e2e:staging
        env:
          PLAYWRIGHT_BASE_URL: ${{ secrets.STAGING_BASE_URL }}
          
      - name: Run API tests
        run: |
          # Test consolidated API endpoints are responding  
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/health || exit 1
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/ready || exit 1
          # Test service-specific endpoints through unified gateway
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/api/v1/projects/health || exit 1
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/api/v1/backlog/health || exit 1
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/api/v1/readiness/health || exit 1
          curl -f ${{ secrets.STAGING_API_BASE_URL }}/api/v1/prompt-builder/health || exit 1
          
      - name: Performance benchmarking
        run: |
          # Basic performance check for consolidated API
          response_time=$(curl -o /dev/null -s -w '%{time_total}' ${{ secrets.STAGING_API_BASE_URL }}/health)
          echo "Consolidated API health endpoint response time: ${response_time}s"
          if (( $(echo "$response_time > 2.0" | bc -l) )); then
            echo "❌ Response time too slow: ${response_time}s"
            exit 1
          fi
          echo "✅ Performance check passed for consolidated API"
          
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-test-results
          path: |
            apps/web/playwright-report/
            apps/web/test-results/
          retention-days: 30

  # =============================================================================
  # PRODUCTION DEPLOYMENT PREPARATION
  # =============================================================================
  
  create-production-deployment:
    name: Create Production Deployment Request
    runs-on: ubuntu-latest
    needs: [staging-regression-tests]
    if: success() && github.ref == 'refs/heads/main'
    
    outputs:
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      
    steps:
      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment from main branch',
              required_contexts: [],
              auto_merge: false
            });
            
            core.setOutput('deployment_id', deployment.id);
            
            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.id,
              state: 'pending',
              description: 'Awaiting manual approval for production deployment'
            });

  # =============================================================================
  # NOTIFICATIONS & SUMMARY
  # =============================================================================
  
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [pre-deployment-checks, deploy-staging-backend, deploy-staging-frontend, staging-regression-tests, create-production-deployment]
    
    steps:
      - name: Generate deployment summary
        run: |
          echo "## 🚀 Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Single API Gateway (Consolidated Services)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.pre-deployment-checks.outputs.should_deploy }}" == "true" ]; then
            echo "✅ **Pre-deployment checks:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏭️ **Deployment skipped:** No changes detected" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # API Gateway deployment status (includes all services)
          if [ "${{ needs.pre-deployment-checks.outputs.backend_changed }}" == "true" ]; then
            if [ "${{ needs.deploy-staging-backend.result }}" == "success" ]; then
              echo "✅ **API Gateway deployment:** Successful (All services included)" >> $GITHUB_STEP_SUMMARY
              echo "   - Projects service: Available at /api/v1/projects" >> $GITHUB_STEP_SUMMARY
              echo "   - Backlog service: Available at /api/v1/backlog" >> $GITHUB_STEP_SUMMARY
              echo "   - Readiness service: Available at /api/v1/readiness" >> $GITHUB_STEP_SUMMARY
              echo "   - Prompt Builder service: Available at /api/v1/prompt-builder" >> $GITHUB_STEP_SUMMARY
              echo "   - Context Orchestrator service: Available at /api/v1/context-orchestrator" >> $GITHUB_STEP_SUMMARY
            else
              echo "❌ **API Gateway deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Frontend deployment status
          if [ "${{ needs.pre-deployment-checks.outputs.frontend_changed }}" == "true" ]; then
            if [ "${{ needs.deploy-staging-frontend.result }}" == "success" ]; then
              echo "✅ **Frontend deployment:** Successful" >> $GITHUB_STEP_SUMMARY
            else
              echo "❌ **Frontend deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Regression tests status
          if [ "${{ needs.staging-regression-tests.result }}" == "success" ]; then
            echo "✅ **Regression tests:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Regression tests:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Production deployment status
          if [ "${{ needs.create-production-deployment.result }}" == "success" ]; then
            echo "🎯 **Production deployment:** Ready for approval" >> $GITHUB_STEP_SUMMARY
            echo "[Approve Production Deployment](https://github.com/${{ github.repository }}/deployments)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "- Review staging environment" >> $GITHUB_STEP_SUMMARY
          echo "- Approve production deployment when ready" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment metrics" >> $GITHUB_STEP_SUMMARY

      - name: Notify team
        if: failure()
        run: |
          echo "🚨 Staging deployment failed for commit ${{ github.sha }}"
          echo "Check the workflow run for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"